Question Title,Question Slug,Question ID,Question Text,Topic Tagged text,Topic Tagged ID,Difficulty Level,Success Rate,total submission,total accepted,company tag,Likes,Dislikes,Hints,Similar Questions ID,Similar Questions Text
Flatten 2D Vector,flatten-2d-vector,251,,"Array,Two Pointers,Design,Iterator","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDY0",Medium,47.9,214619,102769,,562,313,"How many variables do you need to keep track? Two variables is all you need. Try with x and y. Beware of empty rows. It could be the first few rows. To write correct code, think about the invariant to maintain. What is it? The invariant is x and y must always point to a valid point in the 2d vector. Should you maintain your invariant ahead of time or right when you need it? Not sure? Think about how you would implement hasNext(). Which is more complex? Common logic in two different places should be refactored into a common method.","173,281,284,341","Binary Search Tree Iterator,Zigzag Iterator,Peeking Iterator,Flatten Nested List Iterator"
Meeting Rooms,meeting-rooms,252,,"Array,Sorting","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjYxMDQ5",Easy,56.7,463131,262491,,1376,67,,"56,253","Merge Intervals,Meeting Rooms II"
Meeting Rooms II,meeting-rooms-ii,253,,"Array,Two Pointers,Greedy,Sorting,Heap (Priority Queue)","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjE3,VG9waWNUYWdOb2RlOjYxMDQ5,VG9waWNUYWdOb2RlOjYxMDUw",Medium,49.6,1250885,620539,,5384,104,"Think about how we would approach this problem in a very simplistic way. We will allocate rooms to meetings that occur earlier in the day v/s the ones that occur later on, right? If you've figured out that we have to sort the meetings by their start time, the next thing to think about is how do we do the allocation? There are two scenarios possible here for any meeting. Either there is no meeting room available and a new one has to be allocated, or a meeting room has freed up and this meeting can take place there. An important thing to note is that we don't really care which room gets freed up while allocating a room for the current meeting. As long as a room is free, our job is done. We already know the rooms we have allocated till now and we also know when are they due to get free because of the end times of the meetings going on in those rooms. We can simply check the room which is due to get vacated the earliest amongst all the allocated rooms. Following up on the previous hint, we can make use of a min-heap to store the end times of the meetings in various rooms. So, every time we want to check if any room is free or not, simply check the topmost element of the min heap as that would be the room that would get free the earliest out of all the other rooms currently occupied.

If the room we extracted from the top of the min heap isn't free, then no other room is. So, we can save time here and simply allocate a new room.","56,252,452,1184","Merge Intervals,Meeting Rooms,Minimum Number of Arrows to Burst Balloons,Car Pooling"
Factor Combinations,factor-combinations,254,,"Array,Backtracking","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjE0",Medium,48.6,217685,105862,,890,48,,39,Combination Sum
Verify Preorder Sequence in Binary Search Tree,verify-preorder-sequence-in-binary-search-tree,255,,"Stack,Tree,Binary Search Tree,Recursion,Monotonic Stack,Binary Tree","VG9waWNUYWdOb2RlOjE1,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjMw,VG9waWNUYWdOb2RlOjMx,VG9waWNUYWdOb2RlOjYxMDU0,VG9waWNUYWdOb2RlOjYxMDU3",Medium,47.5,134362,63813,,916,68,,144,Binary Tree Preorder Traversal
Paint House,paint-house,256,,"Array,Dynamic Programming","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEz",Medium,58.6,262070,153579,,1747,119,,"198,213,265,276","House Robber,House Robber II,Paint House II,Paint Fence"
Binary Tree Paths,binary-tree-paths,257,"Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. ","String,Backtracking,Tree,Depth-First Search,Binary Tree","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjYxMDU3",Easy,58.5,857207,501173,,3949,181,,"113,1030,2217","Path Sum II,Smallest String Starting From Leaf,Step-By-Step Directions From a Binary Tree Node to Another"
Add Digits,add-digits,258,"Given an integer num, repeatedly add all its digits until the result has only one digit, and return it. ","Math,Simulation,Number Theory","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjYxMDU1,VG9waWNUYWdOb2RlOjYxMDY3",Easy,62.4,743480,463936,,2409,1642,"A naive implementation of the above process is trivial. Could you come up with other methods? What are all the possible results? How do they occur, periodically or randomly? You may find this Wikipedia article useful.","202,1082,2076,2264","Happy Number,Sum of Digits in the Minimum Number,Sum of Digits of String After Convert,Minimum Sum of Four Digit Number After Splitting Digits"
3Sum Smaller,3sum-smaller,259,,"Array,Two Pointers,Binary Search,Sorting","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjYxMDQ5",Medium,50.3,227026,114177,,1232,124,,"15,16,611,1083","3Sum,3Sum Closest,Valid Triangle Number,Two Sum Less Than K"
Single Number III,single-number-iii,260,"Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order. You must write an algorithm that runs in linear runtime complexity and uses only constant extra space. ","Array,Bit Manipulation","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjE5",Medium,67.1,372615,250144,,3806,182,,"136,137","Single Number,Single Number II"
Graph Valid Tree,graph-valid-tree,261,,"Depth-First Search,Breadth-First Search,Union Find,Graph","VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjIz,VG9waWNUYWdOb2RlOjI0",Medium,45.7,554173,253243,,2327,60,"Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree? According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”","207,323,871","Course Schedule,Number of Connected Components in an Undirected Graph,Keys and Rooms"
Trips and Users,trips-and-users,262,"Table: Trips  Table: Users  The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day. Write a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between ""2013-10-01"" and ""2013-10-03"". Round Cancellation Rate to two decimal points. Return the result table in any order. The query result format is in the following example. ",Database,VG9waWNUYWdOb2RlOjYxMDQz,Hard,37.8,298221,112594,,709,454,,"1779,1785,1795","Hopper Company Queries I,Hopper Company Queries II,Hopper Company Queries III"
Ugly Number,ugly-number,263,"An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. ",Math,VG9waWNUYWdOb2RlOjg=,Easy,41.8,699108,292500,,1376,1018,,"202,204,264","Happy Number,Count Primes,Ugly Number II"
Ugly Number II,ugly-number-ii,264,"An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number. ","Hash Table,Math,Dynamic Programming,Heap (Priority Queue)","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjYxMDUw",Medium,45.2,563935,254942,,3941,210,"The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number. The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3. Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).","23,204,263,279,313,1307","Merge k Sorted Lists,Count Primes,Ugly Number,Perfect Squares,Super Ugly Number,Ugly Number III"
Paint House II,paint-house-ii,265,,"Array,Dynamic Programming","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEz",Hard,50.7,185563,94055,,968,33,,"238,239,256,276","Product of Array Except Self,Sliding Window Maximum,Paint House,Paint Fence"
Palindrome Permutation,palindrome-permutation,266,,"Hash Table,String,Bit Manipulation","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE5",Easy,65.4,248715,162569,,860,63,"Consider the palindromes of odd vs even length. What difference do you notice? Count the frequency of each character. If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times?","5,242,267,409","Longest Palindromic Substring,Valid Anagram,Palindrome Permutation II,Longest Palindrome"
Palindrome Permutation II,palindrome-permutation-ii,267,,"Hash Table,String,Backtracking","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0",Medium,39.6,136309,53956,,708,84,"If a palindromic permutation exists, we just need to generate the first half of the string. To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation.","31,47,266","Next Permutation,Permutations II,Palindrome Permutation"
Missing Number,missing-number,268,"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. ","Array,Hash Table,Math,Bit Manipulation,Sorting","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjE5,VG9waWNUYWdOb2RlOjYxMDQ5",Easy,59.3,1649957,977912,,5317,2830,,"41,136,287,770,2107","First Missing Positive,Single Number,Find the Duplicate Number,Couples Holding Hands,Find Unique Binary String"
Alien Dictionary,alien-dictionary,269,,"Array,String,Depth-First Search,Breadth-First Search,Graph,Topological Sort","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjI0,VG9waWNUYWdOb2RlOjI2",Hard,34.8,814197,283406,,3491,718,,210,Course Schedule II
Closest Binary Search Tree Value,closest-binary-search-tree-value,270,,"Binary Search,Tree,Depth-First Search,Binary Search Tree,Binary Tree","VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjMw,VG9waWNUYWdOb2RlOjYxMDU3",Easy,53.7,463260,248677,,1404,86,,"222,272,783","Count Complete Tree Nodes,Closest Binary Search Tree Value II,Search in a Binary Search Tree"
Encode and Decode Strings,encode-and-decode-strings,271,,"Array,String,Design","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjI1",Medium,37.6,247055,93009,,815,227,,"38,297,443,696","Count and Say,Serialize and Deserialize Binary Tree,String Compression,Count Binary Substrings"
Closest Binary Search Tree Value II,closest-binary-search-tree-value-ii,272,,"Two Pointers,Stack,Tree,Depth-First Search,Binary Search Tree,Heap (Priority Queue),Binary Tree","VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjE1,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjMw,VG9waWNUYWdOb2RlOjYxMDUw,VG9waWNUYWdOb2RlOjYxMDU3",Hard,56.8,167444,95078,,1033,33,"Consider implement these two helper functions:
getPredecessor(N), which returns the next smaller node to N.
getSuccessor(N), which returns the next larger node to N. Try to assume that each node has a parent pointer, it makes the problem much easier. Without parent pointer we just need to keep track of the path from the root to the current node using a stack. You would need two stacks to track the path in finding predecessor and successor node separately.","94,270","Binary Tree Inorder Traversal,Closest Binary Search Tree Value"
Integer to English Words,integer-to-english-words,273,Convert a non-negative integer num to its English words representation. ,"Math,String,Recursion","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjMx",Hard,29.6,1008214,298067,,2025,4942,"Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000. Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words. There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)",12,Integer to Roman
H-Index,h-index,274,"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher's h-index. According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each. If there are several possible values for h, the maximum one is taken as the h-index. ","Array,Sorting,Counting Sort","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjYxMDQ5,VG9waWNUYWdOb2RlOjYxMDcy",Medium,37.5,615449,231089,,1197,1802,An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space.,275,H-Index II
H-Index II,h-index-ii,275,"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, return compute the researcher's h-index. According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each. If there are several possible values for h, the maximum one is taken as the h-index. You must write an algorithm that runs in logarithmic time. ","Array,Binary Search","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEx",Medium,37.0,424877,157060,,705,1035,Expected runtime complexity is in O(log n) and the input is sorted.,274,H-Index
Paint Fence,paint-fence,276,,Dynamic Programming,VG9waWNUYWdOb2RlOjEz,Medium,42.8,197036,84256,,1235,354,,"198,213,256,265","House Robber,House Robber II,Paint House,Paint House II"
Find the Celebrity,find-the-celebrity,277,,"Two Pointers,Greedy,Graph,Interactive","VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjE3,VG9waWNUYWdOb2RlOjI0,VG9waWNUYWdOb2RlOjYxMDU5",Medium,46.4,465906,216234,,2241,204,"The best hint for this problem can be provided by the following figure: Well, if you understood the gist of the above idea, you can extend it to find a candidate that can possibly be a celebrity. Why do we say a ""candidate""? That is for you to think. This is clearly a greedy approach to find the answer. However, there is some information that would still remain to be verified without which we can't obtain an answer with certainty. To get that stake in the ground, we would need some more calls to the knows API.",1039,Find the Town Judge
First Bad Version,first-bad-version,278,"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. ","Binary Search,Interactive","VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjYxMDU5",Easy,41.5,2305289,956971,,4654,1743,,"34,35,374","Find First and Last Position of Element in Sorted Array,Search Insert Position,Guess Number Higher or Lower"
Perfect Squares,perfect-squares,279,"Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not. ","Math,Dynamic Programming,Breadth-First Search","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjIy",Medium,51.8,1002301,519105,,6581,291,,"204,264","Count Primes,Ugly Number II"
Wiggle Sort,wiggle-sort,280,,"Array,Greedy,Sorting","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjE3,VG9waWNUYWdOb2RlOjYxMDQ5",Medium,66.0,172096,113554,,907,74,,"75,324,2085","Sort Colors,Wiggle Sort II,Array With Elements Not Equal to Average of Neighbors"
Zigzag Iterator,zigzag-iterator,281,,"Array,Design,Queue,Iterator","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjM0,VG9waWNUYWdOb2RlOjYxMDY0",Medium,61.4,129456,79471,,555,30,,"173,251,284,341,1894","Binary Search Tree Iterator,Flatten 2D Vector,Peeking Iterator,Flatten Nested List Iterator,Merge Strings Alternately"
Expression Add Operators,expression-add-operators,282,"Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value. Note that operands in the returned expressions should not contain leading zeros. ","Math,String,Backtracking","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0",Hard,39.2,460309,180213,,2475,420,"Note that a number can contain multiple digits. Since the question asks us to find all of the valid expressions, we need a way to iterate over all of them. (Hint: Recursion!) We can keep track of the expression string and evaluate it at the very end. But that would take a lot of time. Can we keep track of the expression's value as well so as to avoid the evaluation at the very end of recursion? Think carefully about the multiply operator. It has a higher precedence than the addition and subtraction operators. 

 1 + 2 = 3  
1 + 2 - 4 --> 3 - 4 --> -1 
1 + 2 - 4 * 12 --> -1 * 12 --> -12 (WRONG!) 
1 + 2 - 4 * 12 --> -1 - (-4) + (-4 * 12) --> 3 + (-48) --> -45 (CORRECT!) We simply need to keep track of the last operand in our expression and reverse it's effect on the expression's value while considering the multiply operator.","150,224,227,241,494","Evaluate Reverse Polish Notation,Basic Calculator,Basic Calculator II,Different Ways to Add Parentheses,Target Sum"
Move Zeroes,move-zeroes,283,"Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. ","Array,Two Pointers","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjk=",Easy,60.6,2674454,1619817,,8830,239,"In-place means we should not be allocating any space for extra array. But we are allowed to modify the existing array. However, as a first step, try coming up with a solution that makes use of additional space. For this problem as well, first apply the idea discussed using an additional array and the in-place solution will pop up eventually. A two-pointer approach could be helpful here. The idea would be to have one pointer for iterating the array and another pointer that just works on the non-zero elements of the array.",27,Remove Element
Peeking Iterator,peeking-iterator,284,"Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions. ","Array,Design,Iterator","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDY0",Medium,53.6,291298,156171,,994,685,"Think of ""looking ahead"". You want to cache the next element. Is one variable sufficient? Why or why not? Test your design with call order of peek() before next() vs next() before peek(). For a clean implementation, check out Google's guava library source code.","173,251,281","Binary Search Tree Iterator,Flatten 2D Vector,Zigzag Iterator"
Inorder Successor in BST,inorder-successor-in-bst,285,,"Tree,Depth-First Search,Binary Search Tree,Binary Tree","VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjMw,VG9waWNUYWdOb2RlOjYxMDU3",Medium,47.0,551827,259214,,2081,78,,"94,173,509","Binary Tree Inorder Traversal,Binary Search Tree Iterator,Inorder Successor in BST II"
Walls and Gates,walls-and-gates,286,,"Array,Breadth-First Search,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjYxMDUz",Medium,59.2,362551,214618,,2293,36,,"130,200,317,865,1036","Surrounded Regions,Number of Islands,Shortest Distance from All Buildings,Robot Room Cleaner,Rotting Oranges"
Find the Duplicate Number,find-the-duplicate-number,287,"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. ","Array,Two Pointers,Binary Search,Bit Manipulation","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjE5",Medium,58.8,1384998,814172,,13323,1514,,"41,136,142,268,645","First Missing Positive,Single Number,Linked List Cycle II,Missing Number,Set Mismatch"
Unique Word Abbreviation,unique-word-abbreviation,288,,"Array,Hash Table,String,Design","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjI1",Medium,24.7,260052,64209,,161,1639,,"170,320","Two Sum III - Data structure design,Generalized Abbreviation"
Game of Life,game-of-life,289,"According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."" The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. ","Array,Matrix,Simulation","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjYxMDUz,VG9waWNUYWdOb2RlOjYxMDU1",Medium,65.2,515014,335534,,4649,436,,73,Set Matrix Zeroes
Word Pattern,word-pattern,290,"Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. ","Hash Table,String","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw",Easy,40.2,886230,356008,,3477,402,,"205,291","Isomorphic Strings,Word Pattern II"
Word Pattern II,word-pattern-ii,291,,"Hash Table,String,Backtracking","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0",Medium,46.2,129832,59964,,720,54,,290,Word Pattern
Nim Game,nim-game,292,"You are playing the following Nim Game with your friend: Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. ","Math,Brainteaser,Game Theory","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjMy,VG9waWNUYWdOb2RlOjYxMDcz",Easy,55.5,497284,275879,,1042,2198,"If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?",294,Flip Game II
Flip Game,flip-game,293,,String,VG9waWNUYWdOb2RlOjEw,Easy,62.5,94469,59045,,161,381,,294,Flip Game II
Flip Game II,flip-game-ii,294,,"Math,Dynamic Programming,Backtracking,Memoization,Game Theory","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjE0,VG9waWNUYWdOb2RlOjMz,VG9waWNUYWdOb2RlOjYxMDcz",Medium,51.5,123119,63375,,519,49,,"292,293,375,464","Nim Game,Flip Game,Guess Number Higher or Lower II,Can I Win"
Find Median from Data Stream,find-median-from-data-stream,295,"The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values. Implement the MedianFinder class: ","Two Pointers,Design,Sorting,Heap (Priority Queue),Data Stream","VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDQ5,VG9waWNUYWdOb2RlOjYxMDUw,VG9waWNUYWdOb2RlOjYxMDYz",Hard,50.2,886525,445468,,6641,123,,"480,1953,2207","Sliding Window Median,Finding MK Average,Sequentially Ordinal Rank Tracker"
Best Meeting Point,best-meeting-point,296,,"Array,Math,Sorting,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjYxMDQ5,VG9waWNUYWdOb2RlOjYxMDUz",Hard,59.4,97281,57766,,873,70,Try to solve it in one dimension first. How can this solution apply to the two dimension case?,"317,462","Shortest Distance from All Buildings,Minimum Moves to Equal Array Elements II"
Serialize and Deserialize Binary Tree,serialize-and-deserialize-binary-tree,297,"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. ","String,Tree,Depth-First Search,Breadth-First Search,Design,Binary Tree","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDU3",Hard,53.6,1109191,594595,,6420,250,,"271,449,652,765","Encode and Decode Strings,Serialize and Deserialize BST,Find Duplicate Subtrees,Serialize and Deserialize N-ary Tree"
Binary Tree Longest Consecutive Sequence,binary-tree-longest-consecutive-sequence,298,,"Tree,Depth-First Search,Binary Tree","VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjYxMDU3",Medium,51.1,234391,119775,,881,212,,"128,549,1416","Longest Consecutive Sequence,Binary Tree Longest Consecutive Sequence II,Check if an Array Is Consecutive"
Bulls and Cows,bulls-and-cows,299,"You are playing the Bulls and Cows game with your friend. You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: Given the secret number secret and your friend's guess guess, return the hint for your friend's guess. The hint should be formatted as ""xAyB"", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits. ","Hash Table,String,Counting","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjYxMDYy",Medium,47.1,561240,264594,,1354,1292,,,
Longest Increasing Subsequence,longest-increasing-subsequence,300,"Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. ","Array,Binary Search,Dynamic Programming","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjEz",Medium,49.1,1685924,827984,,11472,227,,"334,354,646,673,712,1766,2096,2234","Increasing Triplet Subsequence,Russian Doll Envelopes,Maximum Length of Pair Chain,Number of Longest Increasing Subsequence,Minimum ASCII Delete Sum for Two Strings,Minimum Number of Removals to Make Mountain Array,Find the Longest Valid Obstacle Course at Each Position,Minimum Operations to Make the Array K-Increasing"
Remove Invalid Parentheses,remove-invalid-parentheses,301,"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return all the possible results. You may return the answer in any order. ","String,Backtracking,Breadth-First Search","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0,VG9waWNUYWdOb2RlOjIy",Hard,46.8,735686,344520,,4569,233,"Since we don't know which of the brackets can possibly be removed, we try out all the options! We can use recursion to try out all possibilities for the given expression. For each of the brackets, we have 2 options:


 We keep the bracket and add it to the expression that we are building on the fly during recursion.
 OR, we can discard the bracket and move on. The one thing all these valid expressions have in common is that they will all be of the same length i.e. as compared to the original expression, all of these expressions will have the same number of characters removed. 

Can we somehow find the number of misplaced parentheses and use it in our solution? For every left parenthesis, we should have a corresponding right parenthesis. We can make use of two counters which keep track of misplaced left and right parenthesis and in one iteration we can find out these two values. 


0 1 2 3 4 5 6 7
( ) ) ) ( ( ( )  
i = 0, left = 1, right = 0
i = 1, left = 0, right = 0
i = 2, left = 0, right = 1
i = 3, left = 0, right = 2
i = 4, left = 1, right = 2
i = 5, left = 2, right = 2
i = 6, left = 3, right = 2
i = 7, left = 2, right = 2


We have 2 misplaced left and 2 misplaced right parentheses. We found out that the exact number of left and right parenthesis that has to be removed to get a valid expression. So, e.g. in a 1000 parentheses string, if there are 2 misplaced left and 2 misplaced right parentheses, after we are done discarding 2 left and 2 right parentheses, we will have only one option per remaining character in the expression i.e. to consider them. We can't discard them.","20,2095","Valid Parentheses,Minimum Number of Swaps to Make the String Balanced"
Smallest Rectangle Enclosing Black Pixels,smallest-rectangle-enclosing-black-pixels,302,,"Array,Binary Search,Depth-First Search,Breadth-First Search,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjYxMDUz",Hard,56.7,71937,40818,,418,83,,,
Range Sum Query - Immutable,range-sum-query-immutable,303,"Given an integer array nums, handle multiple queries of the following type: Implement the NumArray class: ","Array,Design,Prefix Sum","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDY4",Easy,55.2,628000,346813,,1928,1641,,"304,307,325","Range Sum Query 2D - Immutable,Range Sum Query - Mutable,Maximum Size Subarray Sum Equals k"
Range Sum Query 2D - Immutable,range-sum-query-2d-immutable,304,"Given a 2D matrix matrix, handle multiple queries of the following type: Implement the NumMatrix class: ","Array,Design,Matrix,Prefix Sum","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDUz,VG9waWNUYWdOb2RlOjYxMDY4",Medium,47.5,464723,220873,,2502,243,,"303,308","Range Sum Query - Immutable,Range Sum Query 2D - Mutable"
Number of Islands II,number-of-islands-ii,305,,"Array,Union Find","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjIz",Hard,39.3,284469,111911,,1413,42,,"200,2198","Number of Islands,Process Restricted Friend Requests"
Additive Number,additive-number,306,"An additive number is a string whose digits can form an additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. Given a string containing only digits, return true if it is an additive number or false otherwise. Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. ","String,Backtracking","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0",Medium,30.6,224865,68718,,725,625,,872,Split Array into Fibonacci Sequence
Range Sum Query - Mutable,range-sum-query-mutable,307,"Given an integer array nums, handle multiple queries of the following types: Implement the NumArray class: ","Array,Design,Binary Indexed Tree,Segment Tree","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjI4,VG9waWNUYWdOb2RlOjI5",Medium,38.7,464756,179687,,2687,142,,"303,308","Range Sum Query - Immutable,Range Sum Query 2D - Mutable"
Range Sum Query 2D - Mutable,range-sum-query-2d-mutable,308,,"Array,Design,Binary Indexed Tree,Segment Tree,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjI4,VG9waWNUYWdOb2RlOjI5,VG9waWNUYWdOb2RlOjYxMDUz",Hard,41.0,158501,64907,,651,75,,"304,307","Range Sum Query 2D - Immutable,Range Sum Query - Mutable"
Best Time to Buy and Sell Stock with Cooldown,best-time-to-buy-and-sell-stock-with-cooldown,309,"You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions: Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). ","Array,Dynamic Programming","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEz",Medium,52.3,519802,272061,,5575,196,,"121,122","Best Time to Buy and Sell Stock,Best Time to Buy and Sell Stock II"
Minimum Height Trees,minimum-height-trees,310,"A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs). Return a list of all MHTs' root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. ","Depth-First Search,Breadth-First Search,Graph,Topological Sort","VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjI0,VG9waWNUYWdOb2RlOjI2",Medium,38.1,507493,193328,,5092,210,How many MHTs can a graph have at most?,"207,210","Course Schedule,Course Schedule II"
Sparse Matrix Multiplication,sparse-matrix-multiplication,311,,"Array,Hash Table,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjYxMDUz",Medium,66.2,230071,152385,,850,295,,,
Burst Balloons,burst-balloons,312,"You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it. Return the maximum coins you can collect by bursting the balloons wisely. ","Array,Dynamic Programming","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEz",Hard,56.3,325121,182895,,5795,157,,1042,Minimum Cost to Merge Stones
Super Ugly Number,super-ugly-number,313,"A super ugly number is a positive integer whose prime factors are in the array primes. Given an integer n and an array of integers primes, return the nth super ugly number. The nth super ugly number is guaranteed to fit in a 32-bit signed integer. ","Array,Hash Table,Math,Dynamic Programming,Heap (Priority Queue)","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjYxMDUw",Medium,45.8,226970,103863,,1460,278,,264,Ugly Number II
Binary Tree Vertical Order Traversal,binary-tree-vertical-order-traversal,314,,"Hash Table,Tree,Depth-First Search,Breadth-First Search,Binary Tree","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjYxMDU3",Medium,51.1,514798,263089,,2358,258,,102,Binary Tree Level Order Traversal
Count of Smaller Numbers After Self,count-of-smaller-numbers-after-self,315,You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. ,"Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjEy,VG9waWNUYWdOb2RlOjI4,VG9waWNUYWdOb2RlOjI5,VG9waWNUYWdOb2RlOjYxMDUx,VG9waWNUYWdOb2RlOjYxMDcw",Hard,42.0,531794,223619,,5393,154,,"327,406,493,1482,2280","Count of Range Sum,Queue Reconstruction by Height,Reverse Pairs,How Many Numbers Are Smaller Than the Current Number,Count Good Triplets in an Array"
Remove Duplicate Letters,remove-duplicate-letters,316,"Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. ","String,Stack,Greedy,Monotonic Stack","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE1,VG9waWNUYWdOb2RlOjE3,VG9waWNUYWdOb2RlOjYxMDU0",Medium,43.8,432267,189513,,5181,340,Greedily try to add one missing character. How to check if adding some character will not cause problems ? Use bit-masks to check whether you will be able to complete the sub-sequence if you add the character at some index i.,2157,Smallest K-Length Subsequence With Occurrences of a Letter
Shortest Distance from All Buildings,shortest-distance-from-all-buildings,317,,"Array,Breadth-First Search,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjYxMDUz",Hard,43.3,313743,135949,,1525,168,,"286,296,1117","Walls and Gates,Best Meeting Point,As Far from Land as Possible"
Maximum Product of Word Lengths,maximum-product-of-word-lengths,318,"Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0. ","Array,String,Bit Manipulation","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE5",Medium,56.6,251492,142365,,1700,94,,,
Bulb Switcher,bulb-switcher,319,"There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Return the number of bulbs that are on after n rounds. ","Math,Brainteaser","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjMy",Medium,47.2,239996,113307,,907,1636,,"672,1037,1491","Bulb Switcher II,Minimum Number of K Consecutive Bit Flips,Number of Times Binary String Is Prefix-Aligned"
Generalized Abbreviation,generalized-abbreviation,320,,"String,Backtracking,Bit Manipulation","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE0,VG9waWNUYWdOb2RlOjE5",Medium,56.3,107129,60264,,596,205,,"78,288,411","Subsets,Unique Word Abbreviation,Minimum Unique Word Abbreviation"
Create Maximum Number,create-maximum-number,321,You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k. Create the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved. Return an array of the k digits representing the answer. ,"Stack,Greedy,Monotonic Stack","VG9waWNUYWdOb2RlOjE1,VG9waWNUYWdOb2RlOjE3,VG9waWNUYWdOb2RlOjYxMDU0",Hard,28.4,173497,49224,,1323,307,,"402,670","Remove K Digits,Maximum Swap"
Coin Change,coin-change,322,"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. ","Array,Dynamic Programming,Breadth-First Search","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjIy",Medium,40.0,2373497,950323,,10775,262,,"1025,1393,2345","Minimum Cost For Tickets,Maximum Value of K Coins From Piles,Minimum Number of Operations to Convert Time"
Number of Connected Components in an Undirected Graph,number-of-connected-components-in-an-undirected-graph,323,,"Depth-First Search,Breadth-First Search,Union Find,Graph","VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjIz,VG9waWNUYWdOb2RlOjI0",Medium,61.0,399597,243779,,1917,59,,"200,261,547,2218","Number of Islands,Graph Valid Tree,Number of Provinces,Paths in Maze That Lead to Same Room"
Wiggle Sort II,wiggle-sort-ii,324,"Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... You may assume the input array always has a valid answer. ","Array,Divide and Conquer,Sorting,Quickselect","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEy,VG9waWNUYWdOb2RlOjYxMDQ5,VG9waWNUYWdOb2RlOjYxMDY5",Medium,32.2,372665,119965,,2055,793,,"75,215,280,2085","Sort Colors,Kth Largest Element in an Array,Wiggle Sort,Array With Elements Not Equal to Average of Neighbors"
Maximum Size Subarray Sum Equals k,maximum-size-subarray-sum-equals-k,325,,"Array,Hash Table","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=",Medium,49.1,311991,153191,,1628,47,"Compute the prefix sum array where psum[i] is the sum of all the elements from 0 to i. At each index i, the sum of the prefix is psum[i], so we are searching for the index x where psum[x] = psum[i] - k.
The subarray [x + 1, i] will be of sum k. Use a hashmap to get the index x efficiently or to determine that it does not exist.","209,303,525,713","Minimum Size Subarray Sum,Range Sum Query - Immutable,Contiguous Array,Subarray Product Less Than K"
Power of Three,power-of-three,326,"Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. ","Math,Recursion","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjMx",Easy,43.4,1046656,454534,,902,118,,"231,342,1889","Power of Two,Power of Four,Check if Number is a Sum of Powers of Three"
Count of Range Sum,count-of-range-sum,327,"Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j. ","Array,Binary Search,Divide and Conquer,Binary Indexed Tree,Segment Tree,Merge Sort,Ordered Set","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjEy,VG9waWNUYWdOb2RlOjI4,VG9waWNUYWdOb2RlOjI5,VG9waWNUYWdOb2RlOjYxMDUx,VG9waWNUYWdOb2RlOjYxMDcw",Hard,36.0,163712,59005,,1502,155,,"315,493","Count of Smaller Numbers After Self,Reverse Pairs"
Odd Even Linked List,odd-even-linked-list,328,"Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity. ",Linked List,VG9waWNUYWdOb2RlOjc=,Medium,59.5,871544,518520,,5183,383,,725,Split Linked List in Parts
Longest Increasing Path in a Matrix,longest-increasing-path-in-a-matrix,329,"Given an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). ","Dynamic Programming,Depth-First Search,Breadth-First Search,Graph,Topological Sort,Memoization","VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy,VG9waWNUYWdOb2RlOjI0,VG9waWNUYWdOb2RlOjI2,VG9waWNUYWdOb2RlOjMz",Hard,49.6,639552,317264,,5154,88,,,
Patching Array,patching-array,330,"Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. ","Array,Greedy","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjE3",Hard,39.5,141671,55966,,1085,113,,1930,Maximum Number of Consecutive Values You Can Make
Verify Preorder Serialization of a Binary Tree,verify-preorder-serialization-of-a-binary-tree,331,"One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as '#'. For example, the above binary tree can be serialized to the string ""9,3,4,#,#,1,#,#,2,#,6,#,#"", where '#' represents a null node. Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree. It is guaranteed that each comma-separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid. Note: You are not allowed to reconstruct the tree. ","String,Stack,Tree,Binary Tree","VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjE1,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjYxMDU3",Medium,43.7,258229,112808,,1659,81,,,
Reconstruct Itinerary,reconstruct-itinerary,332,"You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from ""JFK"", thus, the itinerary must begin with ""JFK"". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once. ","Depth-First Search,Graph,Eulerian Circuit","VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjI0,VG9waWNUYWdOb2RlOjYxMDc0",Hard,40.1,689553,276521,,3766,1545,,"2051,2201","Longest Common Subpath,Valid Arrangement of Pairs"
Largest BST Subtree,largest-bst-subtree,333,,"Dynamic Programming,Tree,Depth-First Search,Binary Search Tree,Binary Tree","VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjMw,VG9waWNUYWdOb2RlOjYxMDU3",Medium,41.2,197621,81417,,1173,99,"You can recursively use algorithm similar to 98. Validate Binary Search Tree at each node of the tree, which will result in O(nlogn) time complexity.",,
Increasing Triplet Subsequence,increasing-triplet-subsequence,334,"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. ","Array,Greedy","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjE3",Medium,41.5,642716,266546,,3768,208,,"300,2122,2280","Longest Increasing Subsequence,Count Special Quadruplets,Count Good Triplets in an Array"
Self Crossing,self-crossing,335,"You are given an array of integers distance. You start at point (0,0) on an X-Y plane and you move distance[0] meters to the north, then distance[1] meters to the west, distance[2] meters to the south, distance[3] meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise. Return true if your path crosses itself, and false if it does not. ","Array,Math,Geometry","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjM4",Hard,29.1,94557,27512,,249,444,,,
Palindrome Pairs,palindrome-pairs,336,"Given a list of unique words, return all the pairs of the distinct indices (i, j) in the given list, so that the concatenation of the two words words[i] + words[j] is a palindrome. ","Array,Hash Table,String,Trie","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjI3",Hard,35.9,409115,146725,,2618,244,,"5,214,2237","Longest Palindromic Substring,Shortest Palindrome,Longest Palindrome by Concatenating Two Letter Words"
House Robber III,house-robber-iii,337,"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police. ","Dynamic Programming,Tree,Depth-First Search,Binary Tree","VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjYxMDU3",Medium,53.5,528529,282635,,6128,93,,"198,213","House Robber,House Robber II"
Counting Bits,counting-bits,338,"Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i. ","Dynamic Programming,Bit Manipulation","VG9waWNUYWdOb2RlOjEz,VG9waWNUYWdOb2RlOjE5",Easy,74.2,759000,563251,,6774,317,"You should make use of what you have produced already. Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous. Or does the odd/even status of the number help you in calculating the number of 1s?",191,Number of 1 Bits
Nested List Weight Sum,nested-list-weight-sum,339,,"Depth-First Search,Breadth-First Search","VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjIy",Medium,81.0,231221,187385,,1277,292,,"364,565,690","Nested List Weight Sum II,Array Nesting,Employee Importance"
Longest Substring with At Most K Distinct Characters,longest-substring-with-at-most-k-distinct-characters,340,,"Hash Table,String,Sliding Window","VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjU1ODIx",Medium,47.3,572053,270626,,2246,69,,"3,159,424,1034,1046,2134","Longest Substring Without Repeating Characters,Longest Substring with At Most Two Distinct Characters,Longest Repeating Character Replacement,Subarrays with K Different Integers,Max Consecutive Ones III,Maximize the Confusion of an Exam"
Flatten Nested List Iterator,flatten-nested-list-iterator,341,"You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: Your code will be tested with the following pseudocode: If res matches the expected flattened list, then your code will be judged as correct. ","Stack,Tree,Depth-First Search,Design,Queue,Iterator","VG9waWNUYWdOb2RlOjE1,VG9waWNUYWdOb2RlOjIw,VG9waWNUYWdOb2RlOjIx,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjM0,VG9waWNUYWdOb2RlOjYxMDY0",Medium,58.7,484448,284132,,3052,1068,,"251,281,385,565","Flatten 2D Vector,Zigzag Iterator,Mini Parser,Array Nesting"
Power of Four,power-of-four,342,"Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4x. ","Math,Bit Manipulation,Recursion","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjE5,VG9waWNUYWdOb2RlOjMx",Easy,43.9,663170,291168,,1445,285,,"231,326","Power of Two,Power of Three"
Integer Break,integer-break,343,"Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers. Return the maximum product you can get. ","Math,Dynamic Programming","VG9waWNUYWdOb2RlOjg=,VG9waWNUYWdOb2RlOjEz",Medium,54.0,337951,182547,,2696,324,There is a simple O(n) solution to this problem. You may check the breaking results of n ranging from 7 to 10 to discover the regularities.,1936,Maximize Number of Nice Divisors
Reverse String,reverse-string,344,Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. ,"Two Pointers,String,Recursion","VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjEw,VG9waWNUYWdOb2RlOjMx",Easy,74.7,2078623,1553675,,4831,937,The entire logic for reversing a string is based on using the opposite directional two-pointer approach!,"345,541","Reverse Vowels of a String,Reverse String II"
Reverse Vowels of a String,reverse-vowels-of-a-string,345,"Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases. ","Two Pointers,String","VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjEw",Easy,46.9,737331,345831,,1560,1823,,"344,1089","Reverse String,Remove Vowels from a String"
Moving Average from Data Stream,moving-average-from-data-stream,346,,"Array,Design,Queue,Data Stream","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjM0,VG9waWNUYWdOb2RlOjYxMDYz",Easy,76.3,332734,253722,,1255,118,,2211,K Radius Subarray Averages
Top K Frequent Elements,top-k-frequent-elements,347,"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. ","Array,Hash Table,Divide and Conquer,Sorting,Heap (Priority Queue),Bucket Sort,Counting,Quickselect","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjEy,VG9waWNUYWdOb2RlOjYxMDQ5,VG9waWNUYWdOb2RlOjYxMDUw,VG9waWNUYWdOb2RlOjYxMDYw,VG9waWNUYWdOb2RlOjYxMDYy,VG9waWNUYWdOb2RlOjYxMDY5",Medium,65.1,1418616,923599,,8858,360,,"192,215,451,659,692,1014,1919","Word Frequency,Kth Largest Element in an Array,Sort Characters By Frequency,Split Array into Consecutive Subsequences,Top K Frequent Words,K Closest Points to Origin,Sort Features by Popularity"
Design Tic-Tac-Toe,design-tic-tac-toe,348,,"Array,Hash Table,Design,Matrix","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjI1,VG9waWNUYWdOb2RlOjYxMDUz",Medium,57.2,313470,179359,,1626,94,"Could you trade extra space such that move() operation can be done in O(1)? You need two arrays: int rows[n], int cols[n], plus two variables: diagonal, anti_diagonal.",810,Valid Tic-Tac-Toe State
Intersection of Two Arrays,intersection-of-two-arrays,349,"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. ","Array,Hash Table,Two Pointers,Binary Search,Sorting","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjYxMDQ5",Easy,68.9,939599,647468,,2731,1878,,"350,1149,1392,2190,2282","Intersection of Two Arrays II,Intersection of Three Sorted Arrays,Find the Difference of Two Arrays,Count Common Words With One Occurrence,Choose Numbers From Two Arrays in Range"
Intersection of Two Arrays II,intersection-of-two-arrays-ii,350,"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. ","Array,Hash Table,Two Pointers,Binary Search,Sorting","VG9waWNUYWdOb2RlOjU=,VG9waWNUYWdOb2RlOjY=,VG9waWNUYWdOb2RlOjk=,VG9waWNUYWdOb2RlOjEx,VG9waWNUYWdOb2RlOjYxMDQ5",Easy,54.8,1412120,774103,,4292,684,,"349,1044,1392,2282","Intersection of Two Arrays,Find Common Characters,Find the Difference of Two Arrays,Choose Numbers From Two Arrays in Range"
